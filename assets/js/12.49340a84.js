(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{559:function(t,v,s){"use strict";s.r(v);var a=s(9),_=Object(a.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"计算机网络"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络"}},[t._v("#")]),t._v(" 计算机网络")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("网络参考模型")])])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("OSI网络参考模型")]),t._v(" "),s("th",[t._v("协议")]),t._v(" "),s("th",[t._v("TCP/IP")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("7 应用层")]),t._v(" "),s("td",[t._v("DNS、HTTP、SSH、FTP、SMTP...")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("6 表示层")]),t._v(" "),s("td",[t._v("...")]),t._v(" "),s("td",[t._v("5 应用层")])]),t._v(" "),s("tr",[s("td",[t._v("5 会话层")]),t._v(" "),s("td",[t._v("...")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("4 传输层")]),t._v(" "),s("td",[t._v("TCP、UDP、SCTP")]),t._v(" "),s("td",[t._v("4 传输层")])]),t._v(" "),s("tr",[s("td",[t._v("3 网络层")]),t._v(" "),s("td",[t._v("IPv4、IPv6、ARP、ICMP")]),t._v(" "),s("td",[t._v("3 网络层")])]),t._v(" "),s("tr",[s("td",[t._v("2 数据链路层")]),t._v(" "),s("td",[t._v("以太网、无线LAN")]),t._v(" "),s("td",[t._v("2 数据链路层")])]),t._v(" "),s("tr",[s("td",[t._v("1 物理层")]),t._v(" "),s("td",[t._v("光纤、双绞线电缆、无线设备")]),t._v(" "),s("td",[t._v("1 物理层")])])])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("strong",[t._v("什么是HTTP协议？")])])]),t._v(" "),s("p",[t._v("HTTP协议中文名是超文本传输协议，是一种无状态的，以请求、应答的方式运行的协议。是互联网上应用最广泛的一种网络协议。")]),t._v(" "),s("p",[t._v("优点：")]),t._v(" "),s("p",[t._v("1）灵活可扩展的；主要在两个方面，一个是语义上的自由，另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片，视频等任意数据。")]),t._v(" "),s("p",[t._v("2）可靠传输；HTTP基于TCP/IP，因此把着这一特性继承下来了。")]),t._v(" "),s("p",[t._v("3）请求-应答；也就是一发一收，有来有回。")]),t._v(" "),s("p",[t._v("4）无状态；每次http请求都是独立、无关的，默认不需要保留状态信息，在不需要保存连接上下文信息，无状态会减少网络开销，成为了http优点。")]),t._v(" "),s("p",[t._v("缺点：")]),t._v(" "),s("p",[t._v("1）无状态；在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量的重复信息，这时候就是无状态的缺点了。")]),t._v(" "),s("p",[t._v("2）明文传输；即协议里的报文（主要指的是头部）不使用二进制数据，而是文本形式")]),t._v(" "),s("p",[t._v("3）对头阻塞问题；当http开启长连接的时，共用一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长的话，其他请求就处于阻塞状态。")]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[s("strong",[t._v("https协议是什么？")])])]),t._v(" "),s("p",[t._v("是以安全为目标的http通道，简单的来说就http的安全版，即http下加入SSL层，https的安全基础就是SSL。")]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[s("strong",[t._v("http和https的区别是什么？")])])]),t._v(" "),s("p",[t._v("http传输的数据都是未加密的，也就是明文传输，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，比http协议的安全性更高。")]),t._v(" "),s("p",[t._v("主要区别如下：")]),t._v(" "),s("ul",[s("li",[t._v("https协议需要ca证书，费用较高。")]),t._v(" "),s("li",[t._v("http的信息是明文传输的，https则更具有安全性的SSL加密传输协议。")]),t._v(" "),s("li",[t._v("使用不同的连接方式，端口也不同，一般，http协议的端口为80，https的端口为443。")]),t._v(" "),s("li",[t._v("http连接很简单，是无状态的；https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。")])]),t._v(" "),s("ol",{attrs:{start:"5"}},[s("li",[s("strong",[t._v("简述一下TCP三次握手")])])]),t._v(" "),s("p",[t._v("第一次握手：客户端发送报文段，服务端只可以确认自己可以接受客户端发送的报文段；")]),t._v(" "),s("p",[t._v("第二次握手：客户端可以确认服务端收到了自己发送的报文段，并且可以确认自己可以接受服务端发送的报文段；")]),t._v(" "),s("p",[t._v("第三次握手：服务端可以确认客户端收到了自己发送的报文段；")]),t._v(" "),s("ol",{attrs:{start:"6"}},[s("li",[s("strong",[t._v("TCP和UDP的区别？")])])]),t._v(" "),s("ul",[s("li",[t._v("TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立连接。")]),t._v(" "),s("li",[t._v("TCP提供可靠的服务；也就是说通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大的努力交付，即不保证可靠交付。")]),t._v(" "),s("li",[t._v("TCP是面向字节流的，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此可能会出现丢包，对实时的应用比如电话、视频会议等）")]),t._v(" "),s("li",[t._v("TCP只能一对一，而UDP支持一对一，一对多等。")]),t._v(" "),s("li",[t._v("TCP的首部较大，为20字节；而UDP只有8字节。")]),t._v(" "),s("li",[t._v("TCP是面向连接的可靠性传输，而UDP是不可靠的。")])]),t._v(" "),s("ol",{attrs:{start:"7"}},[s("li",[s("strong",[t._v("说一下http2.0")])])]),t._v(" "),s("p",[t._v("http2.0基于1999年发布的http1.0之后的首次更新；内容安全，因为http2.0是基于https；提升了访问速度（相比http1.0，请求资源所需时间更少，访问速度更快）；允许多路复用，可同时通过单一的http/2连接发送多重请求-响应信息。改善了：在http1.1中 ，队头阻塞问题；二进制分帧：http2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码、首部压缩、服务端推送等。")]),t._v(" "),s("ol",{attrs:{start:"8"}},[s("li",[s("strong",[t._v("GET和POST的区别")])])]),t._v(" "),s("ul",[s("li",[t._v("get参数通过url传递，post参数是放在请求体里")]),t._v(" "),s("li",[t._v("get的请求参数是有长度限制的，而post没有")]),t._v(" "),s("li",[t._v("get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息")]),t._v(" "),s("li",[t._v("get请求只能进行url编码，而post支持多种编码方式")]),t._v(" "),s("li",[t._v("get请求浏览器会主动缓存，而post需要手动设置")]),t._v(" "),s("li",[t._v("get产生一个TCP数据包；post产生两个TCP数据包")])]),t._v(" "),s("ol",{attrs:{start:"9"}},[s("li",[s("strong",[t._v("XSS和CSRF的网络攻击及防范")])])]),t._v(" "),s("p",[s("strong",[t._v("CSRF")]),t._v("：跨站请求伪造，字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。防御方式的话：使用验证码，检查 https 头部的 refer，使用 token")]),t._v(" "),s("p",[s("strong",[t._v("XSS")]),t._v("：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻 击，比如获取 cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在 url 地址的请求参数中，防御的话为cookie 设置 httpOnly 属性，对用户的输入进行检查，进行特殊字符过滤。")]),t._v(" "),s("ol",{attrs:{start:"10"}},[s("li",[s("p",[s("strong",[t._v("从输入")]),t._v(" "),s("strong",[t._v("URL")]),t._v(" "),s("strong",[t._v("到页面加载的全过程")])])]),t._v(" "),s("li",[s("p",[t._v("浏览器获取用户输入，等待 url 输入完毕，触发 enter 事件；")])]),t._v(" "),s("li",[s("p",[t._v("解析 URL，分析协议头，再分析主机名是域名还是 IP 地址；")])]),t._v(" "),s("li",[s("p",[t._v("如果主机名是域名的话，则发送一个 DNS 查询请求到 DNS 服务器，获")])])]),t._v(" "),s("p",[t._v("得主机 IP 地址；")]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[t._v("使 用 DNS 获 取 到 主 机 IP 地 址 后 ， 向 目 的 地 址 发 送 一 个")])]),t._v(" "),s("p",[t._v("（http/https/protocol）请求，并且在网络套接字上自动添加端口信息")]),t._v(" "),s("p",[t._v("（http 80 https 443）；")]),t._v(" "),s("ol",{attrs:{start:"5"}},[s("li",[s("p",[t._v("等待服务器响应结果；")])]),t._v(" "),s("li",[s("p",[t._v("将响应结果（html）经浏览器引擎解析后得到 Render tree，浏览器将 Render")])])]),t._v(" "),s("p",[t._v("tree 进行渲染后显示在显示器中，用户此时可以看到页面被渲染。")]),t._v(" "),s("h2",{attrs:{id:"浏览器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[t._v("#")]),t._v(" 浏览器")]),t._v(" "),s("ol",[s("li",[t._v("说一下浏览器缓存")])]),t._v(" "),s("p",[s("img",{attrs:{src:t.$withBase("/interview/01.png")}})]),t._v(" "),s("p",[t._v("浏览器缓存主要分为强"),s("strong",[t._v("强缓存")]),t._v("（也称"),s("strong",[t._v("本地缓存")]),t._v("）和"),s("strong",[t._v("协商缓存")]),t._v("（也称"),s("strong",[t._v("弱缓存")]),t._v("）。根据上图，浏览器在第一次请求发生后，再次发送请求时：")]),t._v(" "),s("ul",[s("li",[t._v("浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的"),s("code",[t._v("Cache-Control")]),t._v("和"),s("code",[t._v("Expires")]),t._v("来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次请求不会与服务器进行通信。这里判断是否过期，则是强缓存相关。")]),t._v(" "),s("li",[t._v("如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的header字段信息，比如客户端会通过"),s("code",[t._v("If-None-Match")]),t._v("头将先前服务器端发送过来的Etag发送给服务器，服务会对比这个客户端发过来的Etag是否与服务器的相同，若相同，就将"),s("code",[t._v("If-None-Match")]),t._v("的值设为false，返回状态304，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将"),s("code",[t._v("If-None-Match")]),t._v("的值设为true，返回状态为200，客户端重新机械服务器端返回的数据；客户端还会通过"),s("code",[t._v("If-Modified-Since")]),t._v("头将先前服务器端发过来的最后修改时间戳发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。")])]),t._v(" "),s("h2",{attrs:{id:"event-loop-及异步机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-及异步机制"}},[t._v("#")]),t._v(" Event Loop 及异步机制")]),t._v(" "),s("p",[t._v("同步任务会在主线程中优先执行；如果遇到异步任务，在异步任务队列中的队列分为两种类型：宏任务（macro-task）和微任务（micro-task）；执行顺序为：首先会执行宏任务队列的对头任务，执行完毕后，再执行微任务队列里的所有任务，执行完毕后会清空微任务中的任务，接着执行宏任务队列中的第二个任务，依次循环。")]),t._v(" "),s("h2",{attrs:{id:"闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),s("blockquote",[s("p",[t._v("闭包是指有权访问另一个函数作用域中变量的函数")])]),t._v(" "),s("h3",{attrs:{id:"产生闭包的原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#产生闭包的原因"}},[t._v("#")]),t._v(" 产生闭包的原因？")]),t._v(" "),s("p",[t._v("其基本原理是作用域和作用域链；ES5中有全局作用域和函数作用域，当访问一个变量时，首先会在当前的作用域下查找变量，如果没有找到就会去父级作用域找，直到找到该变量或者不在作用域中，这就是作用域链。闭包的产生本质就是，当前的函数执行上下文中存在指向父级作用域的引用。")]),t._v(" "),s("h3",{attrs:{id:"使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),s("ul",[s("li",[t._v("返回一个函数")]),t._v(" "),s("li",[t._v("作为函数参数传递")]),t._v(" "),s("li",[t._v("定时器、事件监听、回调函数等都是使用闭包")]),t._v(" "),s("li",[t._v("立即执行函数")])]),t._v(" "),s("h2",{attrs:{id:"原型链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),s("p",[t._v("在 js 中每当定义一个函数数据类型的时候，都会自带一个prototype的属性，这个属性指向的是函数的原型对象。")]),t._v(" "),s("p",[t._v("当函数经过new调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个对象有一个"),s("code",[t._v("__proto__")]),t._v("属性，指向构造函数的原型对象。")]),t._v(" "),s("p",[t._v("在 js 中，原型链就是对象通过"),s("code",[t._v("__proto__")]),t._v("指向父类的原型对象，直到指向 Object 原型对象为止，最终是为 null。这样就形成了一个原型指向的链条，即原型链。")]),t._v(" "),s("p",[t._v("在对象的 "),s("code",[t._v("hasOwnProperty()")]),t._v("来检查对象自身中是否包含该属性；使用"),s("code",[t._v("in")]),t._v("检查对象是否包含某个属性时，如果对象中没有，它会去查找原型链中是否存在。")]),t._v(" "),s("h2",{attrs:{id:"寄生组合继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#寄生组合继承"}},[t._v("#")]),t._v(" 寄生组合继承")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Parent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Parent'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Child")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行Parent构造函数，并改变this指向为当前子类的this")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Parent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nickname "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Child'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 把子类的原型变为父类的原型，并把原型的构造函数改为子类的构造函数")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Child")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Parent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Child")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Child"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])]),s("h2",{attrs:{id:"vue数据响应式原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue数据响应式原理"}},[t._v("#")]),t._v(" Vue数据响应式原理")]),t._v(" "),s("p",[t._v("Vue的数据响应式是实现数据驱动视图的核心原理，当用户改变数据的时候，视图会自动更新。")]),t._v(" "),s("h3",{attrs:{id:"如何实现呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现呢"}},[t._v("#")]),t._v(" 如何实现呢？")]),t._v(" "),s("p",[t._v("使用了数据代理和数据劫持，主要用了"),s("code",[t._v("Object.defineProperty")]),t._v("来遍历data中的属性，将它们转换为getter/setter，并且在内部追踪相关的依赖，在属性被访问和修改的时通知变化。它的优点是让用户不需要操作DOM就能改变视图；缺点就是Vue2用的Api的缺陷导致针对新增的属性的时候没有办法做到响应式，如何解决这个问题呢？Vue3通过使用了Proxy类来解决"),s("code",[t._v("Object.defineProperty")]),t._v("无法监听新增属性的这个问题。")]),t._v(" "),s("h2",{attrs:{id:"作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),s("p",[t._v("在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。通过作用域链我们可以访问到外层环境的变量和函数。")]),t._v(" "),s("h2",{attrs:{id:"computed和watch的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch的区别"}},[t._v("#")]),t._v(" computed和watch的区别")]),t._v(" "),s("p",[t._v("computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。")]),t._v(" "),s("p",[t._v("watch 侦听器 : 更多的是"),s("strong",[t._v("观察")]),t._v("的作用，"),s("strong",[t._v("无缓存性")]),t._v("，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。")]),t._v(" "),s("h2",{attrs:{id:"v-if和v-show的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-show的区别"}},[t._v("#")]),t._v(" v-if和v-show的区别")]),t._v(" "),s("p",[t._v("v-if是动态向DOM树内添加或删除DOM原素；v-show是通过设置DOM元素的display样式属性控制显示和隐藏；性能消耗方面：v-if有更高的切换消耗，v-show有更高的初始渲染消耗；使用场景方面：v-if适合条件不大可能变化的，v-show适合频繁切换。")]),t._v(" "),s("h2",{attrs:{id:"data为什么是一个函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data为什么是一个函数"}},[t._v("#")]),t._v(" data为什么是一个函数？")]),t._v(" "),s("p",[t._v("在vue中有组件化这个概念，我们要复用更多的组件，那就需要每个组件都有自己的数据，这样组件才不会互相干扰；所以组件的数据不能写成一个对象的形式，而要写成函数返回一个对象的形式，这样每当复用组件的时候，就会返回一个新的data对象，这样就避免数据的污染。")]),t._v(" "),s("h2",{attrs:{id:"说说spa"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#说说spa"}},[t._v("#")]),t._v(" 说说SPA")]),t._v(" "),s("p",[t._v("SPA是单页面应用，首屏加载会比较慢，当初次加载文件过多时，需要做相关的优化；不利于SEO，不过可以借助SSR优化SEO。路由模式可以使用hash，也可以使用history。")]),t._v(" "),s("h2",{attrs:{id:"说说你对vue和react的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#说说你对vue和react的理解"}},[t._v("#")]),t._v(" 说说你对Vue和React的理解")]),t._v(" "),s("p",[t._v("相似之处：")]),t._v(" "),s("ul",[s("li",[t._v("都将注意力集中保持在核心库，而将其他功能如路由和状态管理交给相关的库")]),t._v(" "),s("li",[t._v("都有props的概念，允许组件之间的数据传递")]),t._v(" "),s("li",[t._v("都使用了虚拟DOM提高重绘性能")]),t._v(" "),s("li",[t._v("都鼓励组件化开发，提高复用性")])]),t._v(" "),s("p",[t._v("不同之处：")]),t._v(" "),s("ul",[s("li",[t._v("Vue默认支持数据的双向绑定，而React一直提倡单向数据流")]),t._v(" "),s("li",[t._v("Vue从2.0版本开始引入了‘虚拟DOM’，消除了和React这方面的差异\n"),s("ul",[s("li",[t._v("Vue可以更快的计算出虚拟DOM的差异，这是由于他在渲染过程中，会追踪每个组件的依赖关系，不需要重新渲染整个组件树")]),t._v(" "),s("li",[t._v("而React，每当应用的状态被改变时，全部自组件都会重新渲染。可以通过一些方法进行一些优化，但Vue将此默认优化了")])])]),t._v(" "),s("li",[t._v("组件编写方式不同，React采用的是JSX，Vue采用的是近似常规的HTML模版")]),t._v(" "),s("li",[t._v("Vue的数据是可变的，而React更强调数据的不可变")]),t._v(" "),s("li",[t._v("代码复用方面，vue2版本采用的是mixins，而React通过高阶组件（HOC）来扩展；在Vue3版本可以借助组合式api进行代码的复用，也是参考React Hooks来实现的")]),t._v(" "),s("li",[t._v("跨平台：React => React Native. Vue => Weex")])]),t._v(" "),s("h2",{attrs:{id:"对ssr的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对ssr的理解"}},[t._v("#")]),t._v(" 对SSR的理解")]),t._v(" "),s("p",[t._v("SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端")]),t._v(" "),s("p",[t._v("SSR的优势：")]),t._v(" "),s("ul",[s("li",[t._v("更好的SEO")]),t._v(" "),s("li",[t._v("首屏加载速度更快")])]),t._v(" "),s("p",[t._v("SSR的缺点：")]),t._v(" "),s("ul",[s("li",[t._v("开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；")]),t._v(" "),s("li",[t._v("当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；")]),t._v(" "),s("li",[t._v("更多的服务端负载。")])])])}),[],!1,null,null,null);v.default=_.exports}}]);